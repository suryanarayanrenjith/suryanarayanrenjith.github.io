<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <script src="/blocker.js"></script>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-0QSEZ9VSPZ"></script>
  <script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-0QSEZ9VSPZ');
  </script>
  <link rel="apple-touch-icon" sizes="180x180" href="/assets/favicon/apple-touch-icon.png" />
  <link rel="icon" type="image/png" sizes="32x32" href="/assets/favicon/favicon-32x32.png" />
  <link rel="icon" type="image/png" sizes="16x16" href="/assets/favicon/favicon-16x16.png" />
  <link rel="manifest" href="/assets/favicon/site.webmanifest" />
  <title>Space Game</title>
  <style>
    *,*::before,*::after{margin:0;padding:0;box-sizing:border-box}
    html,body{
      width:100%;height:100%;overflow:hidden;
      background:#000;color:#fff;font-family:Arial,sans-serif;
      touch-action:none;user-select:none;-webkit-user-select:none;
      display:flex;justify-content:center;align-items:center;
    }
    canvas{display:block;position:fixed;inset:0;width:100%;height:100%}

    /* ── Overlays ── */
    .overlay{
      position:fixed;inset:0;z-index:10;
      display:flex;flex-direction:column;justify-content:center;align-items:center;
      background:rgba(0,0,0,.85);
      opacity:1;transition:opacity .4s ease;
      pointer-events:auto;
    }
    .overlay.hidden{opacity:0;pointer-events:none}

    .overlay h1{
      font-size:clamp(2rem,6vw,3.5rem);font-weight:700;
      letter-spacing:3px;margin-bottom:8px;color:#fff;
    }
    .overlay .sub{
      font-size:clamp(.85rem,2vw,1.1rem);color:#888;
      margin-bottom:30px;letter-spacing:1px;
    }
    .overlay .score-line{
      font-size:clamp(1rem,2.5vw,1.3rem);color:#ccc;margin-bottom:6px;
    }

    .btn{
      margin-top:20px;padding:12px 36px;
      font:700 clamp(.9rem,2vw,1.1rem)/1 Arial,sans-serif;
      color:#000;background:#fff;border:2px solid transparent;
      cursor:pointer;letter-spacing:1px;
      transition:background .3s,color .3s,border-color .3s,transform .3s;
    }
    .btn:hover,.btn:active{
      background:#000;color:#fff;border-color:#ccc;transform:scale(1.04);
    }

    /* ── HUD ── */
    #hud{
      position:fixed;top:0;left:0;right:0;z-index:5;
      padding:10px 16px;
      display:flex;justify-content:space-between;align-items:flex-start;
      pointer-events:none;font-size:clamp(.7rem,1.8vw,.95rem);
      color:#ccc;letter-spacing:1px;
    }
    #hud .col{display:flex;flex-direction:column;gap:2px}
    .hp-bar{width:clamp(80px,20vw,140px);height:4px;background:#222;margin-top:4px;overflow:hidden}
    .hp-fill{height:100%;background:#fff;transition:width .2s ease}
    .blast-bar{width:clamp(80px,20vw,140px);height:3px;background:#222;margin-top:3px;overflow:hidden}
    .blast-fill{height:100%;background:#666;transition:width .15s ease}

    /* Mobile hint */
    #mobile-hint{
      position:fixed;bottom:clamp(10px,3vh,24px);left:50%;transform:translateX(-50%);
      z-index:5;font-size:clamp(.6rem,1.5vw,.75rem);color:#333;
      letter-spacing:2px;text-transform:uppercase;pointer-events:none;
      opacity:1;transition:opacity 1s ease;
    }
    #mobile-hint.hide{opacity:0}
  </style>
</head>
<body>

<canvas id="c"></canvas>

<!-- HUD -->
<div id="hud" style="display:none">
  <div class="col">
    <div>Score <span id="hScore">0</span></div>
    <div>Best <span id="hBest">0</span></div>
  </div>
  <div class="col" style="align-items:flex-end">
    <div>Level <span id="hLevel">1</span></div>
    <div style="font-size:.7em;color:#555">HP</div>
    <div class="hp-bar"><div class="hp-fill" id="hpFill" style="width:100%"></div></div>
    <div style="font-size:.7em;color:#555;margin-top:3px">Blast</div>
    <div class="blast-bar"><div class="blast-fill" id="blastFill" style="width:100%"></div></div>
  </div>
</div>

<!-- Start screen -->
<div class="overlay" id="startScreen">
  <h1>VOID RUNNER</h1>
  <div class="sub">Navigate the asteroid field</div>
  <button class="btn" id="startBtn">Launch</button>
  <div style="margin-top:20px;font-size:clamp(.65rem,1.5vw,.8rem);color:#444;text-align:center;line-height:1.6">
    Move: Mouse / Touch drag<br>
    Blast: Space / Double-tap
  </div>
</div>

<!-- Game Over screen -->
<div class="overlay hidden" id="overScreen">
  <h1>MISSION OVER</h1>
  <div class="score-line">Score: <span id="oScore">0</span></div>
  <div class="score-line">Best: <span id="oBest">0</span></div>
  <div class="score-line" id="oNewBest" style="color:#fff;display:none">New Record!</div>
  <button class="btn" id="retryBtn">Retry</button>
</div>

<div id="mobile-hint"></div>

<script>
/* ══════════════════════════════════════════════════════════
   VOID RUNNER — B&W Space Survival Game
   High-perf Canvas, object pooling, full mobile support
   ══════════════════════════════════════════════════════════ */
(() => {
'use strict';

/* ── Canvas ── */
const cvs = document.getElementById('c');
const ctx = cvs.getContext('2d', { alpha: false });
let W, H, cx, cy;
let dpr = Math.min(window.devicePixelRatio || 1, 2);

function resize() {
  W = window.innerWidth;
  H = window.innerHeight;
  cvs.width  = W * dpr;
  cvs.height = H * dpr;
  cvs.style.width  = W + 'px';
  cvs.style.height = H + 'px';
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  cx = W / 2;
  cy = H / 2;
}
resize();
window.addEventListener('resize', resize);

/* ── Audio (Web Audio API, minimal) ── */
let audioCtx;
function ensureAudio() { if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }

function playTone(freq, dur, type, vol) {
  if (!audioCtx) return;
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = type || 'sine';
  o.frequency.setValueAtTime(freq, audioCtx.currentTime);
  o.frequency.exponentialRampToValueAtTime(freq * 0.25, audioCtx.currentTime + dur);
  g.gain.setValueAtTime(vol || 0.15, audioCtx.currentTime);
  g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + dur);
  o.connect(g).connect(audioCtx.destination);
  o.start(); o.stop(audioCtx.currentTime + dur);
}

function playNoise(dur, vol) {
  if (!audioCtx) return;
  const buf = audioCtx.createBuffer(1, audioCtx.sampleRate * dur, audioCtx.sampleRate);
  const d = buf.getChannelData(0);
  for (let i = 0; i < d.length; i++) d[i] = Math.random() * 2 - 1;
  const s = audioCtx.createBufferSource();
  const g = audioCtx.createGain();
  const f = audioCtx.createBiquadFilter();
  s.buffer = buf;
  f.type = 'lowpass';
  f.frequency.setValueAtTime(800, audioCtx.currentTime);
  f.frequency.exponentialRampToValueAtTime(20, audioCtx.currentTime + dur);
  g.gain.setValueAtTime(vol || 0.2, audioCtx.currentTime);
  g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + dur);
  s.connect(f).connect(g).connect(audioCtx.destination);
  s.start(); s.stop(audioCtx.currentTime + dur);
}

/* ── Stars (parallax layers) ── */
const STAR_LAYERS = 3;
const STAR_COUNTS = [80, 50, 25];
const STAR_SPEEDS = [0.15, 0.35, 0.7];
const STAR_SIZES  = [0.8, 1.2, 1.8];
let starLayers = [];

function initStars() {
  starLayers = [];
  for (let l = 0; l < STAR_LAYERS; l++) {
    const arr = [];
    for (let i = 0; i < STAR_COUNTS[l]; i++) {
      arr.push({ x: Math.random() * W, y: Math.random() * H });
    }
    starLayers.push(arr);
  }
}
initStars();

function drawStars(dt) {
  for (let l = 0; l < STAR_LAYERS; l++) {
    const spd = STAR_SPEEDS[l];
    const sz  = STAR_SIZES[l];
    const alpha = 0.2 + l * 0.25;
    ctx.fillStyle = `rgba(255,255,255,${alpha})`;
    for (const s of starLayers[l]) {
      s.y += spd * dt * 0.06 * gameSpeed;
      if (s.y > H) { s.y = -2; s.x = Math.random() * W; }
      ctx.fillRect(s.x, s.y, sz, sz);
    }
  }
}

/* ── Object Pools ── */
const MAX_BULLETS  = 60;
const MAX_ENEMIES  = 30;
const MAX_PARTICLES = 300;
const MAX_PICKUPS  = 5;

// Bullet pool
const bx = new Float32Array(MAX_BULLETS);
const by = new Float32Array(MAX_BULLETS);
const bvy = new Float32Array(MAX_BULLETS);
const bActive = new Uint8Array(MAX_BULLETS);
let bulletCount = 0;

function spawnBullet(x, y, vy) {
  for (let i = 0; i < MAX_BULLETS; i++) {
    if (!bActive[i]) {
      bx[i] = x; by[i] = y; bvy[i] = vy;
      bActive[i] = 1;
      bulletCount++;
      return;
    }
  }
}

// Enemy (asteroid) pool
const enemies = [];
function createEnemy() {
  const minDim = Math.min(W, H);
  const sz = 18 + Math.random() * (20 + level * 3);
  const x = Math.random() * (W - sz * 2) + sz;
  const spd = (0.6 + Math.random() * 0.8 + level * 0.08) * gameSpeed;
  const rot = (Math.random() - 0.5) * 0.03;
  // Irregular shape
  const pts = [];
  const n = 6 + (Math.random() * 4) | 0;
  for (let i = 0; i < n; i++) {
    const a = (i / n) * Math.PI * 2;
    const r = sz * (0.7 + Math.random() * 0.3);
    pts.push({ x: Math.cos(a) * r, y: Math.sin(a) * r });
  }
  const hp = level >= 5 ? (Math.random() < 0.3 ? 2 : 1) : 1;
  enemies.push({
    x, y: -sz * 2, sz, spd, angle: 0, rot, pts, hp, maxHp: hp,
    flash: 0, active: true,
    drift: (Math.random() - 0.5) * 0.3
  });
}

// Particle pool
const px = new Float32Array(MAX_PARTICLES);
const py = new Float32Array(MAX_PARTICLES);
const pvx = new Float32Array(MAX_PARTICLES);
const pvy = new Float32Array(MAX_PARTICLES);
const plife = new Float32Array(MAX_PARTICLES);
const pmaxlife = new Float32Array(MAX_PARTICLES);
const psz = new Float32Array(MAX_PARTICLES);
const pActive = new Uint8Array(MAX_PARTICLES);

function spawnParticles(x, y, count, speed, life) {
  let spawned = 0;
  for (let i = 0; i < MAX_PARTICLES && spawned < count; i++) {
    if (!pActive[i]) {
      const a = Math.random() * Math.PI * 2;
      const s = Math.random() * speed;
      px[i] = x; py[i] = y;
      pvx[i] = Math.cos(a) * s;
      pvy[i] = Math.sin(a) * s;
      plife[i] = pmaxlife[i] = life + Math.random() * life * 0.5;
      psz[i] = 1 + Math.random() * 2.5;
      pActive[i] = 1;
      spawned++;
    }
  }
}

// Pickup pool
const pickups = [];
function spawnPickup(x, y) {
  if (pickups.length >= MAX_PICKUPS) return;
  const type = Math.random() < 0.5 ? 'hp' : 'blast';
  pickups.push({ x, y, type, sz: 10, life: 4000, active: true });
}

/* ── Player ── */
const ship = {
  x: 0, y: 0,
  targetX: 0, targetY: 0,
  w: 18, h: 22,
  hp: 5, maxHp: 5,
  invuln: 0,
  trail: [],
};

function drawShip() {
  const { x, y, w, h, invuln } = ship;
  if (invuln > 0 && Math.floor(invuln / 80) % 2 === 0) return; // blink

  // Engine trail
  ctx.globalAlpha = 0.4;
  for (let i = ship.trail.length - 1; i >= 0; i--) {
    const t = ship.trail[i];
    const a = i / ship.trail.length;
    ctx.fillStyle = `rgba(255,255,255,${a * 0.3})`;
    ctx.fillRect(t.x - 1.5, t.y, 3, 3);
  }
  ctx.globalAlpha = 1;

  // Ship body
  ctx.save();
  ctx.translate(x, y);

  // Glow under ship
  ctx.fillStyle = 'rgba(255,255,255,0.06)';
  ctx.beginPath();
  ctx.arc(0, 4, w * 1.5, 0, Math.PI * 2);
  ctx.fill();

  // Ship triangle
  ctx.beginPath();
  ctx.moveTo(0, -h);
  ctx.lineTo(-w, h * 0.6);
  ctx.lineTo(-w * 0.3, h * 0.3);
  ctx.lineTo(0, h * 0.5);
  ctx.lineTo(w * 0.3, h * 0.3);
  ctx.lineTo(w, h * 0.6);
  ctx.closePath();
  ctx.fillStyle = '#fff';
  ctx.fill();
  ctx.strokeStyle = '#ccc';
  ctx.lineWidth = 1;
  ctx.stroke();

  // Cockpit
  ctx.fillStyle = '#000';
  ctx.beginPath();
  ctx.arc(0, -h * 0.2, 3, 0, Math.PI * 2);
  ctx.fill();

  // Engine fire
  const flicker = 3 + Math.random() * 4;
  ctx.fillStyle = `rgba(200,200,200,${0.5 + Math.random() * 0.3})`;
  ctx.beginPath();
  ctx.moveTo(-4, h * 0.5);
  ctx.lineTo(0, h * 0.5 + flicker);
  ctx.lineTo(4, h * 0.5);
  ctx.closePath();
  ctx.fill();

  ctx.restore();
}

/* ── Game State ── */
let gameActive = false;
let score = 0;
let level = 1;
let bestScore = parseInt(localStorage.getItem('voidRunnerBest') || '0');
let gameSpeed = 1;
let blastCharge = 100;
let blastCooldown = 0;
let shakeX = 0, shakeY = 0, shakeDur = 0;
let fireTimer = 0;
const FIRE_RATE = 180; // ms
let spawnTimer = 0;
let levelTimer = 0;
let combo = 0;
let comboTimer = 0;
let isMobile = false;
let pointerDown = false;

// Level thresholds
const LEVEL_SCORES = [0, 200, 500, 1000, 1800, 3000, 4500, 6500, 9000, 12000, Infinity];

/* ── Input ── */
let inputX = 0, inputY = 0;
let hasInput = false;

function onPointerStart(ex, ey) {
  ensureAudio();
  hasInput = true;
  inputX = ex; inputY = ey;
  pointerDown = true;
}
function onPointerMove(ex, ey) {
  if (!hasInput) return;
  inputX = ex; inputY = ey;
}
function onPointerEnd() { pointerDown = false; }

// Mouse
cvs.addEventListener('mousedown', e => { onPointerStart(e.clientX, e.clientY); });
window.addEventListener('mousemove', e => { onPointerMove(e.clientX, e.clientY); });
window.addEventListener('mouseup', onPointerEnd);

// Touch
let lastTapTime = 0;
cvs.addEventListener('touchstart', e => {
  e.preventDefault();
  const t = e.touches[0];
  onPointerStart(t.clientX, t.clientY);
  // Double-tap detection for blast
  const now = performance.now();
  if (now - lastTapTime < 300) triggerBlast();
  lastTapTime = now;
}, { passive: false });
cvs.addEventListener('touchmove', e => {
  e.preventDefault();
  const t = e.touches[0];
  onPointerMove(t.clientX, t.clientY);
}, { passive: false });
cvs.addEventListener('touchend', e => { e.preventDefault(); onPointerEnd(); }, { passive: false });

// Keyboard
const keys = {};
window.addEventListener('keydown', e => {
  keys[e.code] = true;
  if (e.code === 'Space' && gameActive) { e.preventDefault(); triggerBlast(); }
});
window.addEventListener('keyup', e => { keys[e.code] = false; });

// Detect mobile
isMobile = ('ontouchstart' in window) || navigator.maxTouchPoints > 0;
const hintEl = document.getElementById('mobile-hint');
hintEl.textContent = isMobile ? 'Drag to move · Double-tap for blast' : 'Mouse to move · Space for blast';

/* ── Blast (special attack) ── */
function triggerBlast() {
  if (!gameActive || blastCharge < 100 || blastCooldown > 0) return;
  blastCharge = 0;
  blastCooldown = 5000;
  playTone(220, 0.3, 'sine', 0.2);
  playNoise(0.4, 0.15);
  shake(12, 400);

  // Destroy all on screen
  for (let i = enemies.length - 1; i >= 0; i--) {
    const e = enemies[i];
    if (e.active) {
      spawnParticles(e.x, e.y, 15, 3, 500);
      const pts = 30 + (e.sz | 0);
      score += pts;
      if (Math.random() < 0.15) spawnPickup(e.x, e.y);
      e.active = false;
    }
  }

  // White flash
  blastFlash = 1;
}
let blastFlash = 0;

/* ── Screen shake ── */
function shake(intensity, dur) {
  shakeDur = dur;
  shakeX = intensity;
  shakeY = intensity;
}

/* ── HUD ── */
const hudEl = document.getElementById('hud');
const hScoreEl = document.getElementById('hScore');
const hBestEl = document.getElementById('hBest');
const hLevelEl = document.getElementById('hLevel');
const hpFill = document.getElementById('hpFill');
const blastFillEl = document.getElementById('blastFill');

function updateHUD() {
  hScoreEl.textContent = score;
  hBestEl.textContent = bestScore;
  hLevelEl.textContent = level;
  hpFill.style.width = `${(ship.hp / ship.maxHp) * 100}%`;
  blastFillEl.style.width = `${blastCharge}%`;
}

/* ── Screens ── */
const startScreen = document.getElementById('startScreen');
const overScreen  = document.getElementById('overScreen');

document.getElementById('startBtn').addEventListener('click', () => { ensureAudio(); startGame(); });
document.getElementById('retryBtn').addEventListener('click', () => { ensureAudio(); startGame(); });

function startGame() {
  gameActive = true;
  score = 0; level = 1; gameSpeed = 1;
  ship.hp = ship.maxHp;
  ship.invuln = 0;
  ship.x = ship.targetX = cx;
  ship.y = ship.targetY = H * 0.75;
  ship.trail = [];
  inputX = cx; inputY = H * 0.75;
  hasInput = false;
  blastCharge = 100; blastCooldown = 0;
  combo = 0; comboTimer = 0;
  fireTimer = 0; spawnTimer = 0; levelTimer = 0;
  enemies.length = 0; pickups.length = 0;
  bActive.fill(0); bulletCount = 0;
  pActive.fill(0);
  blastFlash = 0;
  shakeDur = 0;

  startScreen.classList.add('hidden');
  overScreen.classList.add('hidden');
  hudEl.style.display = 'flex';
  initStars();
  updateHUD();

  setTimeout(() => { hintEl.classList.add('hide'); }, 4000);
}

function endGame() {
  gameActive = false;
  playTone(880, 1.5, 'sine', 0.15);

  const isNew = score > bestScore;
  if (isNew) { bestScore = score; localStorage.setItem('voidRunnerBest', bestScore); }

  document.getElementById('oScore').textContent = score;
  document.getElementById('oBest').textContent = bestScore;
  document.getElementById('oNewBest').style.display = isNew ? 'block' : 'none';
  overScreen.classList.remove('hidden');
  hudEl.style.display = 'none';
}

/* ── Main Loop ── */
let prev = 0;

function loop(ts) {
  requestAnimationFrame(loop);
  const dt = Math.min(ts - prev, 40);
  prev = ts;

  // === BACKGROUND ===
  ctx.fillStyle = '#000';
  ctx.fillRect(0, 0, W, H);
  drawStars(dt);

  if (!gameActive) return;

  // === SCREEN SHAKE ===
  let sox = 0, soy = 0;
  if (shakeDur > 0) {
    shakeDur -= dt;
    const f = shakeDur / 400;
    sox = (Math.random() - 0.5) * shakeX * f;
    soy = (Math.random() - 0.5) * shakeY * f;
    ctx.save();
    ctx.translate(sox, soy);
  }

  // === BLAST FLASH ===
  if (blastFlash > 0) {
    ctx.fillStyle = `rgba(255,255,255,${blastFlash * 0.3})`;
    ctx.fillRect(0, 0, W, H);
    blastFlash -= dt * 0.004;
    if (blastFlash < 0) blastFlash = 0;
  }

  // === SHIP MOVEMENT ===
  if (hasInput) {
    ship.targetX = inputX;
    ship.targetY = inputY;
  }
  // Keyboard overrides
  const kSpd = 0.4 * dt;
  if (keys['ArrowLeft']  || keys['KeyA']) ship.targetX -= kSpd;
  if (keys['ArrowRight'] || keys['KeyD']) ship.targetX += kSpd;
  if (keys['ArrowUp']    || keys['KeyW']) ship.targetY -= kSpd;
  if (keys['ArrowDown']  || keys['KeyS']) ship.targetY += kSpd;

  const lerp = 1 - Math.pow(0.001, dt / 16);
  ship.x += (ship.targetX - ship.x) * lerp;
  ship.y += (ship.targetY - ship.y) * lerp;

  // Clamp
  ship.x = Math.max(ship.w, Math.min(W - ship.w, ship.x));
  ship.y = Math.max(ship.h + 30, Math.min(H - ship.h - 10, ship.y));

  // Trail
  ship.trail.push({ x: ship.x, y: ship.y + ship.h * 0.5 });
  if (ship.trail.length > 12) ship.trail.shift();

  // Invulnerability
  if (ship.invuln > 0) ship.invuln -= dt;

  // === AUTO-FIRE ===
  fireTimer += dt;
  if (fireTimer >= FIRE_RATE) {
    fireTimer -= FIRE_RATE;
    spawnBullet(ship.x - 5, ship.y - ship.h, -7);
    spawnBullet(ship.x + 5, ship.y - ship.h, -7);
    playTone(1200, 0.05, 'square', 0.04);
  }

  // === SPAWN ENEMIES ===
  const spawnRate = Math.max(1800 - level * 130, 400);
  spawnTimer += dt;
  if (spawnTimer >= spawnRate && enemies.filter(e => e.active).length < 6 + level) {
    spawnTimer = 0;
    createEnemy();
  }

  // === UPDATE BULLETS ===
  ctx.fillStyle = '#fff';
  for (let i = 0; i < MAX_BULLETS; i++) {
    if (!bActive[i]) continue;
    by[i] += bvy[i] * dt * 0.06;
    if (by[i] < -10) { bActive[i] = 0; bulletCount--; continue; }
    ctx.fillRect(bx[i] - 1, by[i], 2, 8);
  }

  // === UPDATE ENEMIES ===
  for (let i = enemies.length - 1; i >= 0; i--) {
    const e = enemies[i];
    if (!e.active) { enemies.splice(i, 1); continue; }

    e.y += e.spd * dt * 0.06;
    e.x += e.drift * dt * 0.06;
    e.angle += e.rot * dt;

    // Off screen bottom
    if (e.y > H + e.sz * 2) {
      e.active = false;
      combo = 0;
      continue;
    }

    // Draw asteroid
    ctx.save();
    ctx.translate(e.x, e.y);
    ctx.rotate(e.angle);
    ctx.beginPath();
    for (let j = 0; j < e.pts.length; j++) {
      j === 0 ? ctx.moveTo(e.pts[j].x, e.pts[j].y) : ctx.lineTo(e.pts[j].x, e.pts[j].y);
    }
    ctx.closePath();

    // Fill gradient
    const gr = ctx.createRadialGradient(0, 0, 0, 0, 0, e.sz);
    gr.addColorStop(0, '#444');
    gr.addColorStop(1, '#111');
    ctx.fillStyle = gr;
    ctx.fill();

    // Stroke
    ctx.strokeStyle = e.flash > 0 ? `rgba(255,255,255,${e.flash})` : 'rgba(255,255,255,0.3)';
    ctx.lineWidth = e.flash > 0 ? 2 : 1;
    ctx.stroke();

    // HP bar for multi-hit
    if (e.maxHp > 1) {
      ctx.fillStyle = '#333';
      ctx.fillRect(-e.sz * 0.4, e.sz + 4, e.sz * 0.8, 2);
      ctx.fillStyle = '#fff';
      ctx.fillRect(-e.sz * 0.4, e.sz + 4, e.sz * 0.8 * (e.hp / e.maxHp), 2);
    }

    ctx.restore();
    if (e.flash > 0) e.flash -= dt * 0.005;

    // Bullet-enemy collision
    for (let b = 0; b < MAX_BULLETS; b++) {
      if (!bActive[b]) continue;
      const dx = bx[b] - e.x;
      const dy = by[b] - e.y;
      if (dx * dx + dy * dy < e.sz * e.sz) {
        bActive[b] = 0; bulletCount--;
        e.hp--;
        e.flash = 1;
        spawnParticles(bx[b], by[b], 4, 1.5, 200);

        if (e.hp <= 0) {
          e.active = false;
          spawnParticles(e.x, e.y, 12, 3, 450);
          playNoise(0.2, 0.12);
          shake(4, 150);

          // Score
          combo++;
          comboTimer = 1500;
          const mult = Math.min(combo, 5);
          const pts = (20 + (e.sz | 0)) * mult;
          score += pts;

          // Pickup chance
          if (Math.random() < 0.12) spawnPickup(e.x, e.y);
        } else {
          playTone(600, 0.05, 'square', 0.06);
        }
        break;
      }
    }

    // Ship-enemy collision
    if (e.active && ship.invuln <= 0) {
      const dx = ship.x - e.x;
      const dy = ship.y - e.y;
      const hitDist = e.sz * 0.7 + ship.w * 0.5;
      if (dx * dx + dy * dy < hitDist * hitDist) {
        ship.hp--;
        ship.invuln = 1500;
        shake(8, 300);
        spawnParticles(ship.x, ship.y, 10, 2, 300);
        playNoise(0.3, 0.2);
        e.active = false;
        spawnParticles(e.x, e.y, 8, 2, 300);

        if (ship.hp <= 0) {
          spawnParticles(ship.x, ship.y, 30, 4, 600);
          endGame();
        }
      }
    }
  }

  // === PICKUPS ===
  for (let i = pickups.length - 1; i >= 0; i--) {
    const p = pickups[i];
    if (!p.active) { pickups.splice(i, 1); continue; }
    p.y += 0.5 * dt * 0.06;
    p.life -= dt;
    if (p.life <= 0 || p.y > H + 20) { pickups.splice(i, 1); continue; }

    // Draw pickup
    const blink = p.life < 1000 ? (Math.sin(p.life * 0.02) * 0.5 + 0.5) : 1;
    ctx.save();
    ctx.translate(p.x, p.y);
    ctx.globalAlpha = blink * 0.8;
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    if (p.type === 'hp') {
      // Plus sign
      ctx.moveTo(-5, 0); ctx.lineTo(5, 0);
      ctx.moveTo(0, -5); ctx.lineTo(0, 5);
    } else {
      // Lightning bolt
      ctx.moveTo(-3, -6); ctx.lineTo(1, -1); ctx.lineTo(-2, -1);
      ctx.lineTo(3, 6); ctx.lineTo(-1, 1); ctx.lineTo(2, 1);
      ctx.closePath();
    }
    ctx.stroke();
    ctx.globalAlpha = 1;
    ctx.restore();

    // Pickup collision
    const dx = ship.x - p.x;
    const dy = ship.y - p.y;
    if (dx * dx + dy * dy < 400) {
      if (p.type === 'hp') ship.hp = Math.min(ship.maxHp, ship.hp + 1);
      else blastCharge = Math.min(100, blastCharge + 40);
      playTone(880, 0.1, 'sine', 0.1);
      spawnParticles(p.x, p.y, 6, 1.5, 200);
      pickups.splice(i, 1);
    }
  }

  // === PARTICLES ===
  for (let i = 0; i < MAX_PARTICLES; i++) {
    if (!pActive[i]) continue;
    px[i] += pvx[i] * dt * 0.06;
    py[i] += pvy[i] * dt * 0.06;
    plife[i] -= dt;
    if (plife[i] <= 0) { pActive[i] = 0; continue; }
    const a = plife[i] / pmaxlife[i];
    const s = psz[i] * a;
    ctx.globalAlpha = a * 0.8;
    ctx.fillStyle = '#fff';
    ctx.fillRect(px[i] - s * 0.5, py[i] - s * 0.5, s, s);
  }
  ctx.globalAlpha = 1;

  // === COMBO TEXT ===
  if (comboTimer > 0) {
    comboTimer -= dt;
    if (comboTimer <= 0) combo = 0;
    if (combo >= 2) {
      const a = Math.min(comboTimer / 500, 1);
      ctx.globalAlpha = a * 0.7;
      ctx.fillStyle = '#fff';
      ctx.font = `700 ${clamp(14, 2.5, 20)}px Arial, sans-serif`;
      ctx.textAlign = 'center';
      ctx.fillText(`${combo}x COMBO`, cx, 60);
      ctx.globalAlpha = 1;
    }
  }

  // === DRAW SHIP ===
  if (gameActive) drawShip();

  // === BLAST COOLDOWN ===
  if (blastCooldown > 0) {
    blastCooldown -= dt;
    if (blastCooldown <= 0) blastCooldown = 0;
  }
  // Auto regen blast
  if (blastCooldown <= 0 && blastCharge < 100) {
    blastCharge = Math.min(100, blastCharge + dt * 0.008);
  }

  // === LEVEL UP ===
  if (level < LEVEL_SCORES.length - 1 && score >= LEVEL_SCORES[level]) {
    level++;
    gameSpeed = 1 + (level - 1) * 0.06;
    playTone(440, 0.15, 'sine', 0.12);
    setTimeout(() => playTone(660, 0.15, 'sine', 0.12), 150);
    setTimeout(() => playTone(880, 0.2, 'sine', 0.12), 300);
  }

  // === HUD ===
  updateHUD();

  // === RESTORE SHAKE ===
  if (shakeDur > 0 || sox || soy) ctx.restore();
}

function clamp(min, vw, max) {
  const v = vw * W / 100;
  return Math.max(min, Math.min(max, v));
}

/* Boot */
hBestEl.textContent = bestScore;
requestAnimationFrame(loop);

})();
</script>
</body>
</html>
